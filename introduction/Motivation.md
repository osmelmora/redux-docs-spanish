# Motivación

Como los requerimientos de las aplicaciones de una sola página (SPA) hechas en Javascript son cada vez más complicados, **nuestro código debe manejar más estado que nunca**. Este estado puede incluir respuestas del servidor y datos cacheados, así como datos creados localmente todavía sin persistir en el servidor. Incluso el estado de las IU aumentan en complejidad, ya que necesitamos lidiar con la ruta activa, el tab seleccionado, si mostrar un indicador de progreso o no, si los controles de paginación están visibles, y más.

Controlar este siempre cambiante estado es difícil. Si un modelo puede actualizar otro modelo, entonces una vista puede actualizar un modelo, y este a la vez actualiza otro modelo que podría provocar que otra vista se actualice, en algún momento dejarás de entender qué pasa en tu aplicación, como habrás **perdido control sobre el cuándo, por qué y cómo de su estado.** Cuando un sistema es opaco y no determinista es difícil reproducir bugs o agregar nuevas funcionalidades.

Como si esto fuera poco, considere los ya cada vez más comunes requerimientos en el desarrollo de productos front-end. Como desarrolladores, se espera de nosotros que manejemos actualizaciones optimistas, rendering en el lado del servidor, que recuperemos datos antes de realizar transiciones de rutas y más. Nos encontramos tratando de manejar una complejidad que nunca habíamos tenido que enfrentar, e inevitablemente viene a la mente la pregunta: [Es tiempo de renunciar?](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html) La respuesta es _no_.

Esta complejidad es difícil de manejar, ya que **estamos mezclando dos conceptos** que son muy complicados para la mente humana: **mutación y asincronía.** Yo les llamo [Mentos y Coke](https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption). Ambos son excelentes por separado, pero juntos pueden crear el caos. Librerías como [React](http://facebook.github.io/react) tratan de resolver este problema en la capa de la vista eliminando a ambos, asincronía y las manipulaciones directas al DOM. Sin embargo, el control del estado de tus datos depende de ti. Aquí es donde entra Redux.

Siguiendo los pasos de [Flux](http://facebook.github.io/flux), [CQRS](http://martinfowler.com/bliki/CQRS.html), y [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html), **Redux trata de hacer mutaciones predecibles al estado** imponiendo ciertas restricciones sobre cómo y cuando las actualizaciones ocurren. Estas restricciones se reflejan en los [tres principios](ThreePrinciples.md) de Redux.
