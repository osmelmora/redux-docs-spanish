# Motivación

Como los requerimientos de las aplicaciones de una sola página (SPA) hechas en Javascript son cada vez más complicados, **nuestro código debe manejar más estado que nunca**. Este estado puede incluir respuestas del servidor y datos cacheados, así como datos creados localmente todavía sin persistir en el servidor. Incluso el estado de las IU aumentan en complejidad, ya que necesitamos lidiar con la ruta activa, el tab seleccionado, si mostrar un indicador de progreso o no, si los controles de paginación están visibles, y más.

Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have **lost control over the when, why, and how of its state.** When a system is opaque and non-deterministic, it’s hard to reproduce bugs or add new features.

Controlar este simpre cambiante estado es difícil. Si un modelo puede actualizar otro modelo, entonces una vista puede actualizar un modelo, y este a la vez actualiza otro modelo que podría provocar que otra vista se actualice, en algún momento dejarás de entender qué pasa en tu aplicación, como habrás **perdido control sobre el cuándo, por qué y cómo del estado.**

As if this wasn’t bad enough, consider the **new requirements becoming common in front-end product development**. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. We find ourselves trying to manage a complexity that we have never had to deal with before, and we inevitably ask the question: [is it time to give up?](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html) The answer is _no_.

This complexity is difficult to handle as **we’re mixing two concepts** that are very hard for the human mind to reason about: **mutation and asynchronicity.** I call them [Mentos and Coke](https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption). Both can be great in separation, but together they create a mess. Libraries like [React](http://facebook.github.io/react) attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.

Following in the steps of [Flux](http://facebook.github.io/flux), [CQRS](http://martinfowler.com/bliki/CQRS.html), and [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html), **Redux attempts to make state mutations predictable** by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the [three principles](ThreePrinciples.md) of Redux.
